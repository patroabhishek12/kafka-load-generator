# Kafka Load Generator (Spring Boot + Kafka + locust4j)

This project is a simple Kafka load generator using:

- Spring Boot (Java 21)
- Spring Kafka
- locust4j (Java worker for Locust)

It is designed to publish messages to Kafka and control throughput (e.g. ~5000 TPS) via a Python Locust master.

## Prerequisites

- Java 21
- Gradle wrapper (`./gradlew` in this project)
- Kafka cluster and topic created
- Python 3 with `locust` installed

Install Locust:

```bash
pip install locust
```

## Configure Kafka & Locust

Edit `src/main/resources/application.yml`:

- `kafka.bootstrap-servers` – your Kafka broker(s)
- `kafka.topic` – topic to publish to (must exist)
- `locust.master-host` / `locust.master-port` – where the Locust master runs

## Build the worker JAR

From the project root:

```bash
./gradlew clean build
```

The fat JAR will be at:

- `build/libs/kafka-load-generator-0.0.1-SNAPSHOT.jar`

## Run Locust master (bare Python)

From the project root (where `locustfile.py` is):

```bash
locust --master --web-port 8089 --expect-workers=1
```

Open the UI at `http://localhost:8089`.

## Run Locust master with Docker

If you prefer not to install Python/Locust directly, you can run the master using Docker:

```bash
# From the project root (where locustfile.py lives)
docker run --rm \
  -p 8089:8089 \   # Locust web UI
  -p 5557:5557 \   # RPC port for workers
  -p 5558:5558 \   # Stats/communication
  -v "$PWD:/mnt/locust" \
  locustio/locust \
  -f /mnt/locust/locustfile.py \
  --master \
  --web-port 8089 \
  --expect-workers=1
```

Then open the UI at `http://localhost:8089`.

## Run the Java worker

Option 1: via JAR

```bash
java -jar build/libs/kafka-load-generator-0.0.1-SNAPSHOT.jar
```

Option 2: via Gradle (uses `bootRun`)

```bash
./gradlew bootRun
```

## How the Locust + locust4j integration works

At a high level:

1. **Locust master (Python)** runs using `locustfile.py` and exposes a web UI.
2. **This Spring Boot app** runs a **locust4j worker** that connects to the master.
3. The worker executes the `KafkaPublishTask` repeatedly according to load generated by Locust.

### Java side (locust4j 2.2.5)

- `KafkaLoadGeneratorApplication` implements `CommandLineRunner`.
  - On startup it:
    - Builds a `Locust` singleton via `Locust.getInstance()`.
    - Configures the master connection from `application.yml`:
      - `locust.master-host`
      - `locust.master-port`
    - Calls `locust.run(kafkaPublishTask);` to start the worker loop.
- `KafkaPublishTask` extends `AbstractTask` from `locust4j`:
  - `getName()` returns `"KafkaPublishTask"` – the name that shows up in Locust.
  - `getWeight()` returns `1` – can be adjusted to bias how often this task runs.
  - `execute()` is called by locust4j to perform one logical operation:
    1. Build a JSON payload.
    2. Call `KafkaLoadService.sendTestMessage(payload)` to publish to Kafka.
    3. Measure latency and report the outcome via `Stats`:
       - `Stats.getInstance().logRequest("kafka", "publish", elapsed, 0L);` on success.
       - `Stats.getInstance().logError("kafka", "publish", e.toString());` on failure.

`locust4j` handles the RPC protocol with the Locust master, task scheduling, and stats aggregation so you only need to implement the task logic.

### Python side (Locust master)

- The `locustfile.py` defines one or more **user classes** that:
  - Connect to the master.
  - Treat the Java worker as a backend that executes `KafkaPublishTask`.
- When you start a swarm from the Locust UI, the master sends commands to the Java worker via locust4j, which in turn drives Kafka traffic.

### Request flow sequence

```text
User (Locust UI)
    |
    | 1. Click "Start swarming" with N users & spawn rate
    v
Locust master (Python)
    |
    | 2. Distributes load generation commands to workers
    v
locust4j worker (this Spring Boot app)
    |
    | 3. `KafkaLoadGeneratorApplication` configures `Locust` with
    |    `locust.master-host` & `locust.master-port`
    | 4. `Locust.run(KafkaPublishTask)` starts worker loop
    |
    | 5. For each scheduled task execution:
    |      - `KafkaPublishTask.execute()` is called
    |      - Payload is built
    |      - `KafkaLoadService.sendTestMessage(payload)` is invoked
    v
Kafka broker
    |
    | 6. Receives message on configured topic
    v
Locust master (Python)
    |
    | 7. Worker reports stats via locust4j `Stats`
    v
User (Locust UI)
    |
    | 8. UI shows Requests/s, failures, latency, etc.
```

## Driving towards ~5000 TPS

1. In the Locust UI, click **Start swarming**.
2. Start with:
   - **Users**: 300
   - **Spawn rate**: 100 users/s
3. Watch **Requests/s** for `kafka/publish`:
   - If you see well below 5000 TPS and no Kafka errors, increase **Users** (e.g. 400, 500).
   - If you see timeouts or broker overload, reduce Users or add more Java workers.

Rule of thumb:

- `users ≈ target_TPS × avg_latency_seconds`
- Example: if average Kafka publish latency is ~50 ms (0.05 s):
  - `users ≈ 5000 × 0.05 ≈ 250`

## Running multiple workers

### Multiple Java workers (bare JAR)

You can start several Java workers (on the same or different machines):

```bash
java -jar build/libs/kafka-load-generator-0.0.1-SNAPSHOT.jar
java -jar build/libs/kafka-load-generator-0.0.1-SNAPSHOT.jar
# ... more instances as needed
```

Then start Locust master with matching `--expect-workers`:

```bash
locust --master --web-port 8089 --expect-workers=3
```

### Docker / docker-compose setup

This project also includes a `Dockerfile` and `docker-compose.yml` so you can run:

- Locust master (Python, in a container)
- Optional Python workers
- Java `locust4j` worker (this Spring Boot app)

From the project root:

```bash
docker-compose up --build
```

This will:

- Start `locust-master` with the UI at `http://localhost:8089`.
- Start a Python `locust-worker` (optional, configurable in `docker-compose.yml`).
- Build and start the `java-worker` service, which runs the Spring Boot app as a locust4j worker and connects to `locust-master`.

The Java worker inside Docker is configured to talk to the Locust master via:

- `locust.master-host=locust-master`
- `locust.master-port=5557`

These are passed as JVM system properties from `docker-compose.yml` so they override the values in `application.yml`.

## Customizing the payload

Edit `src/main/java/com/example/kafkaload/load/KafkaPublishTask.java` in `buildPayload()` to mimic your real message schema and size.

## Kafka producer tuning

Key settings are in `KafkaProducerConfig`:

- `acks`
- `linger.ms`
- `batch.size`
- `compression.type`

Tune these according to your Kafka cluster capacity and latency requirements.
